[11.09.18] - Создал прототип программного комплекса LightSearch (LightSearch Server, LightSearch Admin Panel, LightSearch Android) в 
             стиле языка C.
---------------------------------------------------------------------------------------------------------------------------------------
[09.11.18] - Перевел LightSearch Android с нескольких Activity на Fragment. Теперь одно Activity, и несколько Fragment'ов.
---------------------------------------------------------------------------------------------------------------------------------------
[16.05.19] - Создал layout мягкого чека + его логику обработки(UI-логику + обработчик команды). Изучил и применил Recycle View.
---------------------------------------------------------------------------------------------------------------------------------------
[20.05.19] - Создал layout корзины + его логику обработки(UI-логику + обработчики команд подтверждения товаров мягкого чека и закрытия 
	     мягкого чека).
---------------------------------------------------------------------------------------------------------------------------------------
[23.07.19] - Создал документацию в формате ODT и PDF для пользователей LightSearch Android.
---------------------------------------------------------------------------------------------------------------------------------------
[26.07.19] - Написал ботов (проект LightSearch Client Bot) для тестирования LightSearch Server.
---------------------------------------------------------------------------------------------------------------------------------------
[29.07.19] - Написал юнит-тесты для LightSearch Client Bot.
---------------------------------------------------------------------------------------------------------------------------------------
[01.08.19] - Создал функцию среднего замера времени обработки блока программы LightSearch Server. Для этого создал новую команду, 
	     которую отсылает LightSearch Client Bot после тестирования LightSearch Server'у Системный бот уведомляет о том, что 
	     необходимо посчитать среднее время. Пока что замерял только время отправки сообщения клиенту. Итог - 15 мс. К тому же 
	     провел тест на прочность. Итог - сервер смог выдержать 50 ботов-клиентов, каждый из которых делал 100 циклов по 1000 
	     команд в каждом с задержкой перед отправкой ссобщения в 10 мс.
---------------------------------------------------------------------------------------------------------------------------------------
[05.08.19] - Проверял, сколько потребляет LightSearch Server оперативной памяти. Итог - 17 мегабайт в простое, дальше после каждой 
	     итерации теста с LightSearch Client Bot память увеличивалась на 2к килобайта. Для профилирования использовал Visual VM, 
	     для проверки потребления количества оперативной памяти - диспетчер задач Windows.
---------------------------------------------------------------------------------------------------------------------------------------
[06.08.19] - Создал экспериментальные таймеры с GC (Garbage Collector). Памяти стало лучше, но процессору - нет.
---------------------------------------------------------------------------------------------------------------------------------------
[07.08.19] - Перевел программный комплекс LightSearch с Apache Ant на Apache Maven.
---------------------------------------------------------------------------------------------------------------------------------------
[09.08.19] - Создана новая версия LightSearch Client Bot, написанная на Spring Framework 5 (Spring Boot 2). Конфигурация на аннотациях.
---------------------------------------------------------------------------------------------------------------------------------------
[15.08.19] - Создана новая версия LightSearch Server, написанная на Spring Framework 5 (Spring Boot 2). Конфигурация смешанная 
	     (аннотации + xml).
---------------------------------------------------------------------------------------------------------------------------------------
[15.08.19] - Провел тест потребления оперативной памяти LightSearch Server Spring Edition. Итог - 108 мегабайт. Также использовал 
			 диспетчер задач Windows.
---------------------------------------------------------------------------------------------------------------------------------------
[19.08.19] - Запустил LightSearch Server Standard Edition с ключом -Xmx. Как оказалось, для успешного запуска ему достаточно 4 
	     мегабайта оперативной памяти. Более того, он смог проработать на 4-ех мегабайтах, выдержав 8 клиентов, каждый из которых 
	     делал 500 циклов, в каждом цикле которого 7 команд. LightSearch Server Spring Edition запустился на 7-ми мегабайтах, 
	     выдержав такую же тестовую конфигурацию. Подозреваю, что большую часть оперативной памяти, потребляемый процессом, который 
	     показывал диспетчер задач, потребляет сама Windows. Например, для отрисовки командной строки и обновления вывода текста на 
	     экране.
---------------------------------------------------------------------------------------------------------------------------------------
[20.08.19] - Реорганизовал юнит-тестов в LightSearch Server и LightSearch Client Bot.
---------------------------------------------------------------------------------------------------------------------------------------
[26.08.19] - Написал JavaDoc для LightSearch Server Standard Edition.
---------------------------------------------------------------------------------------------------------------------------------------
[30.08.19] - Изменил отображение результата поиска. Теперь одной записью результата поиска считается уникальный товар 
             (то есть со своим штрих-кодом). В всплывающем окне отображается информация об этом товаре: наименование, ИД (штрих-код),
	     обшее количество товара, цена за единицу, и список подразделений. Каждое подразделение представляет собой наименование
	     подразделения и количество данного товара в этом подразделении.
	     
	     Окно результата поиска никуда не делось и будет использоваться в дальнейшем, если заказчик попросит поиск по наименованию.
	     Теперь карточка представляет из себя карточку товара с общей стоимостью и списком подразделений. Для этого необходимо было
	     генерировать динамически CardView. Для того, чтобы этот эффект был достигнут, необходимо заранее их готовить в AsyncTask,
	     и контролировать, чтобы готовые карточки в адаптере в методе getView() не создавались заново, а вызывались из списка.
	     
	     Улучшил энергоэффективность приложения. Опыт с таймером в LightSearch Server помог. Дело в том, обработчик клиента в цикле
	     постоянно проверяет, нет ли команды на исполнение. Если не ставить задержку, то процессору будет плохо. А на мобильном
	     устройстве еще и аккумулятору. Я поставил задержку в 100 мс и эта проблема была решена.
	     
	     Улучшил UI. Теперь, при нажатии на кнопки и другую область, отличную от текущего EditText, экранная клавиатура закрывается.
	     Навигационная панель (которая внизу и у которой три кнопки: назад, домой и все приложения) теперь цвета заднего плана
	     приложения, что визуально увеличивает площадь.
	     
	     Изменил немного анимацию нажатия кнопок. Теперь нажатия более очевидны.
	     
	     Изменил задержку проверки команды на 500 мс. На скорость это мало влияет (для человека она не заметна), а для памяти и
	     процессора - еще как заметна. Теперь приложение потребляет меньше ресурсов процессора и меньше оперативной памяти.
	     
	     Теперь при показе всплываюшего окна результата поиска нельзя отменить его показ, нажав на любую область экрана. Теперь
	     надо нажимать кнопку "ОК".
---------------------------------------------------------------------------------------------------------------------------------------
[03.09.19] - Сделал кастомный AlertDialog и SpotsDialog. Для этого надо было создать новый drawable background и style. Теперь
             диалоговые окна стали с закругленными краями, и их кнопки стали в стиле кнопок приложения.
             
	     Перенес все строки в файл strings.xml. Небольшие фиксы в UI.

             Пытался добавить шрифт OpenSans, но после его добавления сильной разницы в UI не было замечено, поэтому шрифт остался по
             умолчанию. Также сделал кастомный CheckBox, но такую хорошую анимацию, как в CheckBox по умолчанию, я сделать не смог, 
             поэтому оставил новый drawable на потом, когда научусь делать анимацию.
---------------------------------------------------------------------------------------------------------------------------------------
[05.09.19] - Создал авто-обновление LightSearch Android. Для этого был написан сервис LightSearch Updater, работающий с фреймворком
             Spring. Для Android приложения была использована библиотека AppUpdater. Но она не удовлетворяля по нескольким причинам:
	     1) Нельзя изменить View диалогового окна; 2) Кнопка "Больше не напоминать" - у нас не такое приложение, где можно включать
	     такую функцию. Библиотека не дает делать такие настройки, поэтому были скачаны ее исходники, и весь необходимый функционал
	     был вытащен и внедрен в проект, также были добавлены новые функции, и все остальное ненужное - удалено. 
	     
	     Теперь, когда мобильное приложение запускается, оно проверяет наличие обновления, и если оно таковое имеется, то
	     предлагает пользователю обновится. Если он соглашается, то открывается браузер, скачивается apk, и приложение обновляется.
---------------------------------------------------------------------------------------------------------------------------------------
[12.09.19] - Создал панель администратора LightSearch Updater, используя Spring Boot, MVC, Security, и Vaadin. Теперь, набрав в поиске
             адрес сервера, открывается форма с авторизацией. После успешного входа в систему открывается страница панели 
	     администратора. При помощи нее можно создавать новые версии релиза мобильного приложения LightSearch Android, загружая
	     файл обновления через технологию Drag-and-Drop и введя название релиза. Также можно изменять информацию о релизе, которую
	     считывает мобильное приложение для проверки обновления, непосредственно в браузере. При этом поддерживается проверка
	     синтаксиса JSON.
---------------------------------------------------------------------------------------------------------------------------------------
[17.09.19] - Написал юнит-тесты для LightSearch Updater, используя JUnit, TestNG и Mockito. В TestNG применил Suite XML. Это позволило
             перенести все простые параметры в него, и сконфигурировать запуск тестов по пакетам.
---------------------------------------------------------------------------------------------------------------------------------------
[01.11.19] - Переписал LightSearch Server на REST. API сервера будет скоро описано в соответствующем документе. Здесь я отмечу, что 
             выбрана именно такая модель API (то есть когда одна точка для нескольких команд, а название самой команды передается в 
	     JSON) потому, что с текущей схемой работы сервера создание для каждой команды точки приведет только к дублированию кода.
	     
	     В REST версии сервера я применил из проекта Spring Cloud создание задач по расписанию. На текущий момент реализовано три
	     задачи, одна из которых стоит под вопросом:
	     1) Таймер тайм-аута клиента. Если на сервере тайм-аут клиента включен, то каждую секунду происходит уменьшение значения
	     времени тайм-аута всех подключенных клиентов на 1. После этого идет проверка на значение тайм-аута: если оно равно 0, то
	     клиент исключается из текущей сессии;
	     2) Таймер записи значения LSCODE в файл. Этот таймер каждые 30 минут записывает значение LSCODE в файл db_identifier;
	     3) RestartTimer - перезагружает сервер в определенное время. Данный таймер стоит под вопросом надобности вообще: можно 
	     оставить перезагрузку только как команду администратора. Также было замечено, что если сервер перезагружать без остановки,
	     но с задержкой, то приложение рано или поздно выведит ошибку java.lang.outOfMemoryError. Есть предположение, что это 
	     просто от того, что сервер не успевает вычищать память после каждой перезагрузки, то есть в реальной эксплуатации этого не
	     должно произойти. Но этот сценарий будет проверяться тестами.
	     
	     Теперь настройки сервера хранятся в файле application.properties. Доступные настройки:
	     1) lightsearch.server.settings.timeout.client-timeout - значение тайм-аута клиента, в секундах;
	     2) lightsearch.server.settings.timeout.reduce-value - значение, на которое каждую секунду уменьшается значение тайм-аута 
	     клиента, в секундах;
	     3) lightsearch.server.settings.restart.restart-time - время перезагрузки сервера. Паттерн значения времени: HH:ss;
	     4) lightsearch.server.settings.restart.frequency - указывает, через какое количество дней необходимо перезагружать сервер.
	     Например, если указано число 1, то это означает, что сервер будет перезагружаться каждый день. Значение, равное 0, 
	     указывать только в случае теста и отладки!
	     5) lightsearch.server.admin.username - имя администратора. В версии Spring нет надобности в нескольких администраторов, 
	     поэтому параметры одного (и единственного) из них можно записать в property файл.
	     6) lightsearch.server.admin.password - пароль администратора. В данном случае это дайджест пароля. В текущей версии 
	     LightSearch Server используется алгоритм bcrypt с 10 раундами.
	     
	     Для общения с СУБД был использован интерфейс JdbcTemplate. Hibernate пока что не был применен по причине того, что его
	     необходимо изучать и также делать проверку при помощи тестов, а это время. Времени пока нет, поэтому был сделан более
	     быстрый вариант. Проблема также в том, что на предприятии СУБД Firebird работает на кодировке windows-1251, что создает 
	     еще больше проблем для применения Hibernate.
	     
	     Для тестов была использована база данных H2. Для того, чтобы H2 была использована только в тестах, необходимо в папке
	     test/resources создать файл application.properties с настройками H2.
	     Для создания базы необходимо два файла: data.sql и schema.sql. В schema.sql указывается схема бд, а в data.sql - данные.
	     При работе с H2 возникли некоторые трудности: я не смог перевести корректно BLOB в String. Все советы, решения и 
	     официальная документация не помогли, и все, что мне оставалось сделать, это сохранять команду в поле VARCHAR. Но нужно
	     понимать, что это только для тестов. В реальной базе следует использовать BLOB, т.к. он банально способен держать намного
	     больше объем данных.
---------------------------------------------------------------------------------------------------------------------------------------
